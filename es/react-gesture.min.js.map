{"version":3,"file":"react-gesture.min.js","sources":["../src/react/useIsomorphicLayoutEffect.ts","../src/react/useEvents.ts","../src/emitter/index.ts","../src/utils/index.ts","../src/core/index.ts","../src/events/common.ts","../src/events/started.ts","../src/events/moved.ts","../src/events/ended.ts","../src/events/canceled.ts","../src/events/downed.ts","../src/events/wheeled.ts","../src/react/index.tsx"],"sourcesContent":["/*\n * @Author: Huangjs\n * @Date: 2023-08-24 16:40:36\n * @LastEditors: Huangjs\n * @LastEditTime: 2023-08-24 16:40:43\n * @Description: ******\n */\n\nimport React from 'react';\n\nexport const canUseDOM = !!(\n  typeof window !== 'undefined' &&\n  typeof window.document !== 'undefined' &&\n  typeof window.document.createElement !== 'undefined'\n);\n\nexport const useIsomorphicLayoutEffect = canUseDOM ? React.useLayoutEffect : React.useEffect;\n","/*\n * @Author: Huangjs\n * @Date: 2023-08-22 16:15:47\n * @LastEditors: Huangjs\n * @LastEditTime: 2023-10-10 11:33:15\n * @Description: ******\n */\n\nimport { useIsomorphicLayoutEffect } from './useIsomorphicLayoutEffect';\nimport type Core from '../core';\nimport { type IGestureEvent, type IGestureEventType } from '../core';\nimport { type IHandler, type IGestureHandler } from './index';\n\nfunction useEvent(getCore: () => Core | null, type: IGestureEventType, onEvent?: IHandler): void {\n  useIsomorphicLayoutEffect(() => {\n    const core = getCore();\n    if (core) {\n      const handler = (e: IGestureEvent) => {\n        if (typeof onEvent === 'function') {\n          onEvent.apply(null, [e]);\n        }\n      };\n      core.on(type, handler);\n      return () => {\n        core.off(type, handler);\n      };\n    }\n    return () => {};\n  }, [onEvent, type, getCore]);\n}\nexport function useEvents(events: IGestureHandler, getCore: () => Core | null): void {\n  const {\n    onPan,\n    onTap,\n    onSwipe,\n    onSingleTap,\n    onLongTap,\n    onDoubleTap,\n    onMultiPan,\n    onScale,\n    onRotate,\n    onPointerStart,\n    onPointerMove,\n    onPointerEnd,\n    onPointerCancel,\n    onGestureStart,\n    onGestureMove,\n    onGestureEnd,\n  } = events;\n  useEvent(getCore, 'pan', onPan);\n  useEvent(getCore, 'tap', onTap);\n  useEvent(getCore, 'swipe', onSwipe);\n  useEvent(getCore, 'singleTap', onSingleTap);\n  useEvent(getCore, 'longTap', onLongTap);\n  useEvent(getCore, 'doubleTap', onDoubleTap);\n  useEvent(getCore, 'multiPan', onMultiPan);\n  useEvent(getCore, 'scale', onScale);\n  useEvent(getCore, 'rotate', onRotate);\n  useEvent(getCore, 'pointerStart', onPointerStart);\n  useEvent(getCore, 'pointerMove', onPointerMove);\n  useEvent(getCore, 'pointerEnd', onPointerEnd);\n  useEvent(getCore, 'pointerCancel', onPointerCancel);\n  useEvent(getCore, 'gestureStart', onGestureStart);\n  useEvent(getCore, 'gestureMove', onGestureMove);\n  useEvent(getCore, 'gestureEnd', onGestureEnd);\n}\n","/*\n * @Author: Huangjs\n * @Date: 2023-02-13 15:22:58\n * @LastEditors: Huangjs\n * @LastEditTime: 2023-09-14 09:46:11\n * @Description: ******\n */\n\ntype IEventHandler<E, T> = (event: E, type?: T) => boolean | void;\n\nexport default class EventEmitter<T extends string, E> {\n  events: {\n    [key in T]?: {\n      pool: Array<IEventHandler<E, T>>;\n      single: number;\n    };\n  } = {};\n  constructor() {\n    this.events = {};\n  }\n  one(type: T, handler: IEventHandler<E, T>, single?: boolean) {\n    const onceHandler =\n      typeof handler === 'function'\n        ? (...args: [E, T?]) => {\n            // 该事件只执行一次，执行完就解除事件\n            handler.apply(null, args);\n            this.off(type, onceHandler, single);\n          }\n        : handler;\n    this.on(type, onceHandler, single);\n  }\n  on(type: T, handler: IEventHandler<E, T>, single?: boolean) {\n    const events = this.events[type] || {\n      pool: [],\n      single: -1,\n    };\n    if (typeof handler === 'function') {\n      if (single) {\n        // 该事件只能注册一次，每次注册都会替换上次注册的，类似于dom属性事件赋值注册比如element.onclick = ()=>{}\n        if (events.single === -1) {\n          // 记录该单独事件在所有事件的位置\n          events.single = events.pool.push(handler) - 1;\n        } else {\n          events.pool[events.single] = handler;\n        }\n      } else {\n        // 该事件可以注册多次，执行时，会遍历全部事件全部执行，类似于dom的addEventListener\n        // 注册进去之前会检查是否有相同的处理程序，如果有，则不再添加（独立程序不参与）\n        let unregistered = true;\n        for (let i = 0, len = events.pool.length; i < len; i++) {\n          if (events.pool[i] === handler && i !== events.single) {\n            unregistered = false;\n            break;\n          }\n        }\n        if (unregistered) {\n          events.pool.push(handler);\n        }\n      }\n    } else if (single && events.single !== -1) {\n      // 需要把独立事件删除，相当于解绑独立事件\n      events.pool.splice(events.single, 1);\n      events.single = -1;\n    }\n    this.events[type] = events;\n  }\n  off(type?: T, handler?: IEventHandler<E, T>, single?: boolean) {\n    if (typeof type === 'undefined') {\n      // 没有type则删除全部事件\n      this.events = {};\n    } else if (typeof handler === 'undefined') {\n      // 删除type下的所有事件\n      delete this.events[type];\n    } else if (single) {\n      const events = this.events[type];\n      if (events && events.single !== -1) {\n        // 删除独立程序事件\n        events.pool.splice(events.single, 1);\n        events.single = -1;\n      }\n    } else {\n      const events = this.events[type];\n      if (events) {\n        // 检查并删除事件池内事件\n        for (let i = events.pool.length - 1; i >= 0; i--) {\n          if (events.pool[i] === handler && i !== events.single) {\n            events.pool.splice(i, 1);\n            // 因为相同事件只会有一个，所以删除后不需要再检查了\n            break;\n          }\n        }\n      }\n    }\n  }\n  emit(type: T, event: E) {\n    const events = this.events[type];\n    if (events) {\n      // 循环执行事件池里的事件\n      for (let i = 0, len = events.pool.length; i < len; i++) {\n        const handler = events.pool[i];\n        if (typeof handler === 'function') {\n          const immediatePropagation = handler.apply(null, [event, type]);\n          // 返回值为false，则阻止后于该事件注册的同类型事件触发\n          if (immediatePropagation === false) {\n            break;\n          }\n        }\n      }\n    }\n  }\n}\n","/*\n * @Author: Huangjs\n * @Date: 2023-02-13 15:22:58\n * @LastEditors: Huangjs\n * @LastEditTime: 2023-10-20 12:26:31\n * @Description: ******\n */\n\nconst isCurrentTarget = (target: HTMLElement, currentTarget: HTMLElement) => {\n  let _target: HTMLElement | null = target;\n  while (_target && _target !== currentTarget) {\n    _target = _target.parentNode as HTMLElement;\n  }\n  return !!_target;\n};\n\nexport function fixOption(value: number | undefined, defaultValue: number, minVal: number) {\n  return typeof value !== 'number' || value < minVal ? defaultValue : value;\n}\n\nexport function isTouchable() {\n  return window.navigator.maxTouchPoints || 'ontouchstart' in window.document;\n}\n\nexport function getEventPoints(\n  event: any,\n  started: boolean = false,\n): {\n  points: { pageX: number; pageY: number; identifier: number }[];\n  isFirst?: boolean;\n} {\n  if (event.touches) {\n    if (started) {\n      const points = Array.prototype.filter\n        .call(event.touches, (t: any) =>\n          isCurrentTarget(t.target as HTMLElement, event.currentTarget as HTMLElement),\n        )\n        .map((t: any) => ({\n          pageX: t.pageX,\n          pageY: t.pageY,\n          identifier: t.identifier,\n        }));\n      return {\n        points,\n        isFirst: event.changedTouches.length === points.length,\n      };\n    }\n\n    return {\n      points: Array.prototype.slice.call(event.changedTouches || []).map((t: any) => ({\n        pageX: t.pageX,\n        pageY: t.pageY,\n        identifier: t.identifier,\n      })),\n    };\n  }\n  return {\n    points: [{ pageX: event.pageX, pageY: event.pageY, identifier: -1 }],\n    isFirst: started,\n  };\n}\n\nexport function getDistance([x0, y0]: number[], [x1, y1]: number[]) {\n  if (\n    typeof x0 === 'number' &&\n    typeof x1 === 'number' &&\n    typeof y0 === 'number' &&\n    typeof y1 === 'number'\n  ) {\n    return Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2));\n  }\n  return 0;\n}\n\nexport function getAngle([x0, y0]: number[], [x1, y1]: number[]) {\n  if (\n    typeof x0 === 'number' &&\n    typeof x1 === 'number' &&\n    typeof y0 === 'number' &&\n    typeof y1 === 'number'\n  ) {\n    return (Math.atan2(y1 - y0, x1 - x0) * 180) / Math.PI;\n  }\n  return 0;\n}\n\nexport function getCenter([x0, y0]: number[], [x1, y1]: number[]) {\n  const ok0 = typeof x0 === 'number' && typeof y0 === 'number';\n  const ok1 = typeof x1 === 'number' && typeof y1 === 'number';\n  return !ok0 && !ok1\n    ? [0, 0]\n    : ok0 && !ok1\n    ? [x0, y0]\n    : !ok0 && ok1\n    ? [x1, y1]\n    : [(x0 + x1) / 2, (y0 + y1) / 2];\n}\n\nexport function getDirection([x0, y0]: number[], [x1, y1]: number[]) {\n  if (\n    typeof x0 === 'number' &&\n    typeof x1 === 'number' &&\n    typeof y0 === 'number' &&\n    typeof y1 === 'number'\n  ) {\n    const x = x0 - x1;\n    const y = y0 - y1;\n    if (x !== y) {\n      return Math.abs(x) >= Math.abs(y)\n        ? x0 - x1 > 0\n          ? 'Left'\n          : 'Right'\n        : y0 - y1 > 0\n        ? 'Up'\n        : 'Down';\n    }\n  }\n  return 'None';\n}\n\nexport function getVelocity(deltaTime: number, distance: number) {\n  if (\n    typeof distance !== 'number' ||\n    distance === 0 ||\n    typeof deltaTime !== 'number' ||\n    deltaTime === 0\n  ) {\n    return 0;\n  }\n  return distance / deltaTime;\n}\n\n//根据数值，与水平夹角，计算x和y的分量值\nexport function getVector(value: number, angle: number) {\n  if (typeof value !== 'number' || typeof angle !== 'number') {\n    return [0, 0];\n  }\n  const rad = (angle * Math.PI) / 180;\n  return [value * Math.cos(rad), value * Math.sin(rad)];\n}\n","/*\n * @Author: Huangjs\n * @Date: 2023-08-23 09:36:07\n * @LastEditors: Huangjs\n * @LastEditTime: 2023-10-23 14:33:37\n * @Description: ******\n */\n\nimport EventEmitter from '../emitter';\nimport { fixOption } from '../utils';\n\nclass Gesture extends EventEmitter<IGestureEventType, IGestureEvent> {\n  wheelDelay: number = 350;\n  longTapInterval: number = 750;\n  doubleTapInterval: number = 250;\n  doubleTapDistance: number = 30;\n  touchMoveDistance: number = 3;\n  swipeVelocity: number = 0.3;\n  swipeDuration: number = 100;\n  raiseDuration: number = 100;\n  _rotateAngle: number = 0;\n  _noMouseTimer: number = 0;\n  _singleTapTimer: number = 0;\n  _longTapTimer: number = 0;\n  _wheelTimerEnd: {\n    scale: number;\n    timer: number;\n    wheelEnd: () => void;\n  } | null = null;\n  _preventTap: boolean = true;\n  _swipePoints: any[] | null = null;\n  _preventSingleTap: boolean = true;\n  _preventDoubleTap: boolean = true;\n  _firstPointer: IGesturePointer | null = null;\n  _pointer0: IGesturePointer | null = null;\n  _pointer1: IGesturePointer | null = null;\n  constructor(options?: IGestureOptions) {\n    super();\n    this.resetOptions(options);\n  }\n  resetOptions(options?: IGestureOptions) {\n    const {\n      wheelDelay,\n      longTapInterval,\n      doubleTapInterval,\n      doubleTapDistance,\n      touchMoveDistance,\n      swipeVelocity,\n      swipeDuration,\n      raiseDuration,\n    } = options || {};\n    this.wheelDelay = fixOption(wheelDelay, 350, 1);\n    this.longTapInterval = fixOption(longTapInterval, 750, 1);\n    this.doubleTapInterval = fixOption(doubleTapInterval, 250, 1);\n    this.doubleTapDistance = fixOption(doubleTapDistance, 30, 1);\n    this.touchMoveDistance = fixOption(touchMoveDistance, 3, 0);\n    this.swipeVelocity = fixOption(swipeVelocity, 0.3, 0);\n    this.swipeDuration = fixOption(swipeDuration, 100, 1);\n    this.raiseDuration = fixOption(raiseDuration, 100, 1);\n  }\n  preventAllTap(fp: boolean = true) {\n    this._preventTap = true;\n    this._preventSingleTap = true;\n    this._preventDoubleTap = true;\n    if (fp) {\n      this._firstPointer = null;\n    }\n    if (this._longTapTimer) {\n      clearTimeout(this._longTapTimer);\n      this._longTapTimer = 0;\n    }\n  }\n}\n\nexport type IGestureOptions = {\n  wheelDelay?: number; // 设置wheel等待时间，超时则认为结束滚动，单位ms\n  longTapInterval?: number; // 设置长按等待时间阈值，单位ms\n  doubleTapInterval?: number; // 设置双击时间间隔，单位ms\n  doubleTapDistance?: number; // 双击两次点击的位置距离触发阈值\n  touchMoveDistance?: number; // 移动阈值，超过这个值才算移动\n  swipeVelocity?: number; // swipe阶段的速率大于这个值才会触发swipe\n  swipeDuration?: number; // 移动过程中计入swipe的时间范围，即：最后一次移动事件向前推swipeDuration时间内，作为swipe阶段\n  raiseDuration?: number; // 最后一次移动到手指（点）抬起的时间间隔，小于这个值才会触发swipe\n};\n\nexport type IGestureDirection = 'Left' | 'Right' | 'Up' | 'Down' | 'None';\n\nexport type IGestureEventType =\n  | 'pan' // 平移\n  | 'tap' // 轻点（快，双击时会触发）\n  | 'swipe' // 快速滑动\n  | 'singleTap' // 点击（有延迟，双击时不触发）\n  | 'longTap' // 长按\n  | 'doubleTap' // 双击\n  | 'multiPan' // 平移\n  | 'scale' // 缩放\n  | 'rotate' // 旋转\n  | 'pointerStart' // 开始\n  | 'pointerMove' // 移动\n  | 'pointerEnd' // 抬起\n  | 'pointerCancel' // 触摸取消\n  | 'gestureStart' // 双（多）指开始\n  | 'gestureMove' // 双（多）指移动\n  | 'gestureEnd'; // 双（多）指结束\n\nexport type IGesturePointer = {\n  start: number[]; // 开始点\n  previous: number[]; // 上一个点\n  current: number[]; // 当前点\n  identifier: number; // 手指（点）id\n  changed: boolean; // 手指（点）是否变化\n};\n\nexport type IGestureEvent = {\n  pointers: IGesturePointer[]; // 当前停留在界面上的所有手指（点）\n  leavePointers: IGesturePointer[]; // 已经离开界面的所有手指（点）\n  getPoint: (whichOne?: 'start' | 'previous' | 'current') => number[]; // 获取当前点（两个点取中心值）参数是获取起点，还是当前点，还是移动时的上个点\n  scale?: number; // 缩放比例（和上一个点比较）\n  angle?: number; // 旋转角度（和上一个点比较）swipe角度\n  deltaX?: number; // x方向距离（和上一个点比较）\n  deltaY?: number; // y方向距离（和上一个点比较）\n  direction?: IGestureDirection; // 移动时的方向（和上一个点比较）swipe方向\n  moveScale?: number; // 缩放比例（和起点比较）\n  moveAngle?: number; // 旋转角度（和起点比较）\n  moveX?: number; // x方向距离（和起点比较）\n  moveY?: number; // y方向距离（和起点比较）\n  moveDirection?: IGestureDirection; // 移动时的方向（和起点比较）\n  velocity?: number; // swipe阶段速率（不是从起点到终点的速率）\n  waitTime?: number; // 长按等待时间\n  delayTime?: number; // 点击延迟时间\n  intervalTime?: number; // 双击间隔时间\n  swipeComputed?: (\n    factor: number,\n    _velocity?: number,\n  ) => {\n    duration: number; // swipe速率减到0花费的时间\n    stretchX: number; // x方向swipe惯性距离（抬起后，继续移动的距离）\n    stretchY: number; // y方向swipe惯性距离（抬起后，继续移动的距离）\n    deceleration: number; // swipe速率减到0的减速度\n  };\n  timestamp: number;\n  sourceEvent: any;\n  isTouching: () => boolean; // 判断当前操作是不是触摸操作\n  preventDefault: () => void; // 阻止原生事件默认行为，相当于sourceEvent.preventDefault\n  stopPropagation: () => void; // 阻止原生事件冒泡，相当于sourceEvent.stopPropagation\n  stopImmediatePropagation: () => void; // 阻止原生事件冒泡及其后注册的未执行事件执行，相当于sourceEvent.stopImmediatePropagation（如果有的情况下，react合成事件没有）\n};\n\nexport default Gesture;\n","/*\n * @Author: Huangjs\n * @Date: 2023-08-23 11:27:38\n * @LastEditors: Huangjs\n * @LastEditTime: 2023-10-11 11:40:38\n * @Description: ******\n */\n\nexport function preventDefault(this: any) {\n  if (this.nativeEvent) {\n    //react事件\n    // https://github.com/facebook/react/issues/6436\n    // Chrome 73之后，所有绑定在根节点（window,document,body）的scroll,wheel,mobile touch事件都会默认passive为true\n    // 这就会导致事件内调用e.preventDefault()无效，还会报错：Unable to preventDefault inside passive event listener invocation.\n    // react是合成事件，所有事件最终会冒泡到document上进行执行，而document默认是passive为true，并且react注册事件上没有可以设置passive的地方\n    // 所以这里不管调用e.preventDefault()还是e.nativeEvent.preventDefault()都没有任何卵用，还报错。\n    return;\n  } else {\n    if (!this.preventDefault) {\n      this.returnValue = false;\n    } else {\n      this.preventDefault();\n    }\n  }\n}\n\nexport function stopPropagation(this: any) {\n  if (!this.stopPropagation) {\n    this.cancelBubble = true;\n  } else {\n    this.stopPropagation();\n  }\n}\n\nexport function stopImmediatePropagation(this: any) {\n  if (this.nativeEvent) {\n    //react事件\n    // react是合成事件，没有在同一元素注册多个事件的可能，所以不存在stopImmediatePropagation\n    // 调用e.nativeEvent.stopImmediatePropagation()是为了阻止在document上注册的多个事件\n    if (this.nativeEvent.stopImmediatePropagation) {\n      this.nativeEvent.stopImmediatePropagation();\n    }\n  } else {\n    if (!this.stopImmediatePropagation) {\n      stopPropagation.apply(this, []);\n    } else {\n      this.stopImmediatePropagation();\n    }\n  }\n}\n","/*\n * @Author: Huangjs\n * @Date: 2023-08-23 11:27:38\n * @LastEditors: Huangjs\n * @LastEditTime: 2023-10-20 12:38:57\n * @Description: ******\n */\n\nimport { preventDefault, stopPropagation, stopImmediatePropagation } from './common';\nimport { isTouchable, getEventPoints, getDistance, getCenter } from '../utils';\nimport type Core from '../core';\nimport { type IGestureEvent } from '../core';\n\nexport default function started(this: Core, event: any) {\n  const newEvent: IGestureEvent = {\n    sourceEvent: event,\n    timestamp: Date.now(),\n    pointers: [],\n    leavePointers: [],\n    getPoint: () => [0, 0],\n    isTouching: () => !!isTouchable() && !!event.touches,\n    preventDefault: preventDefault.bind(event),\n    stopPropagation: stopPropagation.bind(event),\n    stopImmediatePropagation: stopImmediatePropagation.bind(event),\n  };\n  const { points, isFirst } = getEventPoints(event, true);\n  // 表示第一次放入手指（点）\n  if (isFirst) {\n    // 第一次点击，如果存在wheel没执行，需要执行掉\n    if (this._wheelTimerEnd) {\n      clearTimeout(this._wheelTimerEnd.timer);\n      this._wheelTimerEnd.wheelEnd();\n      this._wheelTimerEnd = null;\n    }\n    this._pointer0 = null;\n    this._pointer1 = null;\n  } else {\n    if (this._pointer0) {\n      this._pointer0.changed = false;\n    }\n    if (this._pointer1) {\n      this._pointer1.changed = false;\n    }\n  }\n  // 如果当前事件元素之外的屏幕上有手指（点），此时在事件元素上放一个手指（点），points会包含该手指（点）\n  // 循环保存放在屏幕上的手指（点），这里只会保存最多两个，忽略超过三个的手指（点）（只对单指和双指情形处理）\n  for (let i = 0, len = points.length; i < len; ++i) {\n    const t = points[i];\n    const p = [t.pageX, t.pageY];\n    const pointer = {\n      start: p,\n      previous: p,\n      current: p,\n      identifier: t.identifier,\n      changed: true,\n    };\n    if (!this._pointer0) {\n      this._pointer0 = pointer;\n    } else if (!this._pointer1 && this._pointer0.identifier !== t.identifier) {\n      this._pointer1 = pointer;\n    }\n  }\n  // 每次进入时先阻止所有单指事件\n  this.preventAllTap(false);\n  this._swipePoints = null;\n  this._rotateAngle = 0;\n  // 双指start\n  const pointer0 = this._pointer0;\n  const pointer1 = this._pointer1;\n  if (pointer1 && pointer0) {\n    this._firstPointer = null;\n    newEvent.pointers = [pointer0, pointer1];\n    newEvent.getPoint = () => getCenter(pointer0.current, pointer1.current);\n    this.emit('gestureStart', newEvent);\n  }\n  // 单指start\n  else if (pointer0) {\n    newEvent.pointers = [pointer0];\n    newEvent.getPoint = () => pointer0.current;\n    this._preventTap = false;\n    // 设置一个长按定时器\n    this._longTapTimer = +setTimeout(() => {\n      // 当前点击一旦长按超过longTapInterval则触发longTap，则松开后不会再触发所有单指事件\n      this._preventTap = true;\n      this._preventSingleTap = true;\n      this._preventDoubleTap = true;\n      this._longTapTimer = 0;\n      this._firstPointer = null;\n      newEvent.waitTime = this.longTapInterval;\n      this.emit('longTap', newEvent);\n    }, this.longTapInterval);\n    const firstPointer = this._firstPointer;\n    const singleTapTimer = this._singleTapTimer;\n    if (\n      singleTapTimer &&\n      firstPointer &&\n      getDistance(firstPointer.current, pointer0.current) < this.doubleTapDistance\n    ) {\n      // 1，只要连续两次点击时间在doubleTapInterval之内，距离在doubleTapDistance内，无论第二次作何操作，都不会触发第一次的singleTap，但第一次的tap会触发\n      // 2，如果满足第一条时，第二次的点击有多根手指（点），或者长按触发longTap，则不会再触发doubleTap，第二次的tap，singleTap也不会触发\n      clearTimeout(singleTapTimer);\n      this._singleTapTimer = 0;\n      this._preventSingleTap = true;\n      this._preventDoubleTap = false;\n      newEvent.getPoint = () => firstPointer.current;\n    } else {\n      this._firstPointer = pointer0;\n      // 表示是第一次点击或该次点击距离上一次点击时间超过doubleTapInterval，距离超过doubleTapDistance\n      this._preventSingleTap = false;\n      this._preventDoubleTap = true;\n    }\n  }\n  // 无指没有start\n  else {\n    return;\n  }\n  this.emit('pointerStart', newEvent);\n}\n","/*\n * @Author: Huangjs\n * @Date: 2023-08-23 11:27:38\n * @LastEditors: Huangjs\n * @LastEditTime: 2023-10-20 12:36:15\n * @Description: ******\n */\n\nimport { preventDefault, stopPropagation, stopImmediatePropagation } from './common';\nimport {\n  isTouchable,\n  getEventPoints,\n  getDirection,\n  getDistance,\n  getAngle,\n  getCenter,\n} from '../utils';\nimport type Core from '../core';\nimport { type IGestureEvent } from '../core';\n\nexport default function moved(this: Core, event: any) {\n  const newEvent: IGestureEvent = {\n    sourceEvent: event,\n    timestamp: Date.now(),\n    pointers: [],\n    leavePointers: [],\n    getPoint: () => [0, 0],\n    isTouching: () => !!isTouchable() && !!event.touches,\n    preventDefault: preventDefault.bind(event),\n    stopPropagation: stopPropagation.bind(event),\n    stopImmediatePropagation: stopImmediatePropagation.bind(event),\n  };\n  if (this._pointer0) {\n    this._pointer0.changed = false;\n  }\n  if (this._pointer1) {\n    this._pointer1.changed = false;\n  }\n  // 循环更新手指（点）\n  const { points } = getEventPoints(event);\n  for (let i = 0, len = points.length; i < len; ++i) {\n    const t = points[i];\n    const p = [t.pageX, t.pageY];\n    if (this._pointer0 && this._pointer0.identifier === t.identifier) {\n      this._pointer0.changed = true;\n      this._pointer0.previous = this._pointer0.current;\n      this._pointer0.current = p;\n    } else if (this._pointer1 && this._pointer1.identifier === t.identifier) {\n      this._pointer1.changed = true;\n      this._pointer1.previous = this._pointer1.current;\n      this._pointer1.current = p;\n    }\n  }\n  // 手指（点）移动至少要有一个手指（点）移动超过touchMoveDistance才会触发移动事件\n  const pointer0 = this._pointer0;\n  const pointer1 = this._pointer1;\n  if (\n    (pointer0 && getDistance(pointer0.start, pointer0.current) > this.touchMoveDistance) ||\n    (pointer1 && getDistance(pointer1.start, pointer1.current) > this.touchMoveDistance)\n  ) {\n    // 一旦移动，则阻止所有单指点击相关事件（除了swipe）\n    this.preventAllTap();\n    // 双指移动情况\n    if (pointer1 && pointer0) {\n      newEvent.pointers = [pointer0, pointer1];\n      const { start: start0, previous: previous0, current: current0 } = pointer0;\n      const { start: start1, previous: previous1, current: current1 } = pointer1;\n      // 双指平移\n      const eCenter = getCenter(current0, current1);\n      const mCenter = getCenter(previous0, previous1);\n      const sCenter = getCenter(start0, start1);\n      newEvent.getPoint = (whichOne) =>\n        whichOne === 'start' ? sCenter : whichOne === 'previous' ? mCenter : eCenter;\n      newEvent.direction = getDirection(mCenter, eCenter);\n      newEvent.moveDirection = getDirection(sCenter, eCenter);\n      newEvent.deltaX = eCenter[0] - mCenter[0];\n      newEvent.moveX = eCenter[0] - sCenter[0];\n      newEvent.deltaY = eCenter[1] - mCenter[1];\n      newEvent.moveY = eCenter[1] - sCenter[1];\n      // 只有双指滑动时才会触发下面事件\n      const eDistance = getDistance(current0, current1);\n      const mDistance = getDistance(previous0, previous1);\n      const sDistance = getDistance(start0, start1);\n      if (sDistance > 0 && eDistance > 0 && mDistance > 0) {\n        // 双指缩放\n        newEvent.scale = eDistance / mDistance;\n        newEvent.moveScale = eDistance / sDistance;\n      }\n      const eAngle = getAngle(current0, current1);\n      const mAngle = getAngle(previous0, previous1);\n      // const sAngle = getAngle(start0, start1);\n      // 这里计算的三个angle均是向量（第一个参数为起点，第二个为终点）与x正半轴之间的夹角\n      // 方向朝向y轴正半轴的为正值[0,180]，朝向y轴负半轴的为负值[-180,0]\n      // 注意，这里坐标轴是页面坐标，x轴向右正方向，y轴向下正方向，原点在左上角\n      let angle = eAngle - mAngle;\n      if (angle < -180) {\n        // 此种情况属于顺时针转动时mAngle突然由正变为负值（比如由178度顺时针旋转4度都-178度）\n        // 这种情况，因为eAngle和mAngle是两次相邻的移动事件，间隔角度很小（4度）而不会是很大的（-356度）\n        angle += 360;\n      } else if (angle > 180) {\n        // 和上面相反逆时针转动（比如由-178逆时针旋转4度到178）\n        angle -= 360;\n      }\n      // 双指旋转本次和上一次的角度，正值顺时针，负值逆时针\n      newEvent.angle = angle;\n      // 双指旋转起点到终点的总旋转角度，正值顺时针，负值逆时针\n      // 这里不能直接使用eAngle-sAngle，否则顺逆时针分不清，需要通过angle累加\n      this._rotateAngle += angle;\n      newEvent.moveAngle = this._rotateAngle;\n      this.emit('rotate', newEvent);\n      if (sDistance > 0 && eDistance > 0 && mDistance > 0) {\n        this.emit('scale', newEvent);\n      }\n      this.emit('multiPan', newEvent);\n      this.emit('gestureMove', newEvent);\n    }\n    // 单指移动\n    else if (pointer0) {\n      newEvent.pointers = [pointer0];\n      const { start, previous, current } = pointer0;\n      newEvent.getPoint = (whichOne) =>\n        whichOne === 'start' ? start : whichOne === 'previous' ? previous : current;\n      newEvent.direction = getDirection(previous, current);\n      newEvent.moveDirection = getDirection(start, current);\n      newEvent.deltaX = current[0] - previous[0];\n      newEvent.moveX = current[0] - start[0];\n      newEvent.deltaY = current[1] - previous[1];\n      newEvent.moveY = current[1] - start[1];\n      const _timestamp = Date.now();\n      // 第一次移动this._swipePoints为null\n      const _swipePoints = this._swipePoints || [[], []];\n      const _duration = _timestamp - ((_swipePoints[1][0] ? _swipePoints[1][0].timestamp : 0) || 0);\n      // 当前时间与本阶段初始时间之差大于计入swipe的时间(swipeDuration)，则本阶段过时，下阶段开启\n      if (_duration > this.swipeDuration) {\n        // 将本阶段作为上一阶段，开启下一阶段作为本阶段\n        _swipePoints[0] = _swipePoints[1];\n        _swipePoints[1] = [];\n      }\n      // 将当前移动点和时间存入本阶段\n      _swipePoints[1].push({\n        point: current,\n        timestamp: _timestamp,\n      });\n      this._swipePoints = _swipePoints;\n      // 触发单指平移事件\n      this.emit('pan', newEvent);\n    }\n    // 无指无移动\n    else {\n      return;\n    }\n    this.emit('pointerMove', newEvent);\n  }\n}\n","/*\n * @Author: Huangjs\n * @Date: 2023-08-23 11:27:38\n * @LastEditors: Huangjs\n * @LastEditTime: 2023-10-23 14:41:50\n * @Description: ******\n */\n\nimport { preventDefault, stopPropagation, stopImmediatePropagation } from './common';\nimport {\n  isTouchable,\n  getEventPoints,\n  getDirection,\n  getDistance,\n  getAngle,\n  getCenter,\n  getVelocity,\n  getVector,\n} from '../utils';\nimport type Core from '../core';\nimport { type IGestureEvent, type IGesturePointer } from '../core';\n\nexport default function ended(this: Core, event: any) {\n  const newEvent: IGestureEvent = {\n    sourceEvent: event,\n    timestamp: Date.now(),\n    pointers: [],\n    leavePointers: [],\n    getPoint: () => [0, 0],\n    isTouching: () => !!isTouchable() && !!event.touches,\n    preventDefault: preventDefault.bind(event),\n    stopPropagation: stopPropagation.bind(event),\n    stopImmediatePropagation: stopImmediatePropagation.bind(event),\n  };\n  if (!!isTouchable() && !!event.touches) {\n    if (this._noMouseTimer) {\n      clearTimeout(this._noMouseTimer);\n    }\n    this._noMouseTimer = +setTimeout(() => {\n      this._noMouseTimer = 0;\n    }, this.doubleTapInterval);\n  }\n  // 临时保存当前手指（点）\n  let pointer0: IGesturePointer | null = null;\n  let pointer1: IGesturePointer | null = null;\n  if (this._pointer0) {\n    this._pointer0.changed = false;\n  }\n  if (this._pointer1) {\n    this._pointer1.changed = false;\n  }\n  // 循环删除已经拿开的手指（点）\n  const { points } = getEventPoints(event);\n  for (let i = 0, len = points.length; i < len; ++i) {\n    const t = points[i];\n    if (this._pointer0 && this._pointer0.identifier === t.identifier) {\n      this._pointer0.changed = true;\n      pointer0 = this._pointer0;\n      this._pointer0 = null;\n    } else if (this._pointer1 && this._pointer1.identifier === t.identifier) {\n      this._pointer1.changed = true;\n      pointer1 = this._pointer1;\n      this._pointer1 = null;\n    }\n  }\n  // 双指变单指\n  if (this._pointer1 && !this._pointer0) {\n    this._pointer0 = this._pointer1;\n    this._pointer1 = null;\n    pointer1 = pointer0;\n    pointer0 = null;\n  }\n  // 松开时清除longTapTimer（一旦松开就不存在长按，当然有可能已经发生过了）\n  if (this._longTapTimer) {\n    clearTimeout(this._longTapTimer);\n    this._longTapTimer = 0;\n  }\n  // 仍然存在至少一根手指（点）\n  if (this._pointer0) {\n    newEvent.pointers = [this._pointer0];\n    if (this._pointer1) {\n      // 剩余两指\n      newEvent.pointers.push(this._pointer1);\n    } else if (pointer1) {\n      // 剩余一指\n      newEvent.leavePointers = [pointer1];\n      this._rotateAngle = 0;\n    }\n    const start = getCenter(\n      this._pointer0.start,\n      this._pointer1 ? this._pointer1.start : pointer1 ? pointer1.start : [],\n    );\n    const previous = getCenter(\n      this._pointer0.previous,\n      this._pointer1 ? this._pointer1.previous : pointer1 ? pointer1.previous : [],\n    );\n    const current = getCenter(\n      this._pointer0.current,\n      this._pointer1 ? this._pointer1.current : pointer1 ? pointer1.current : [],\n    );\n    newEvent.getPoint = (whichOne) =>\n      whichOne === 'start' ? start : whichOne === 'previous' ? previous : current;\n    this.emit('gestureEnd', newEvent);\n  }\n  // 全部拿开\n  else if (pointer0) {\n    // 多指的最后一指抬起，仅仅一指抬起\n    newEvent.leavePointers = [pointer0];\n    if (pointer1) {\n      // 双指同时抬起\n      newEvent.leavePointers.push(pointer1);\n    }\n    const start = pointer1 ? getCenter(pointer0.start, pointer1.start) : pointer0.start;\n    const previous = pointer1 ? getCenter(pointer0.previous, pointer1.previous) : pointer0.previous;\n    const current = pointer1 ? getCenter(pointer0.current, pointer1.current) : pointer0.current;\n    newEvent.getPoint = (whichOne) =>\n      whichOne === 'start' ? start : whichOne === 'previous' ? previous : current;\n    if (!this._preventTap) {\n      this.emit('tap', newEvent);\n      this._preventTap = true;\n    }\n    if (!this._preventSingleTap) {\n      // 等待doubleTapInterval，如果时间内没有点击第二次，则触发\n      this._singleTapTimer = +setTimeout(() => {\n        this._singleTapTimer = 0;\n        newEvent.delayTime = this.doubleTapInterval;\n        this.emit('singleTap', newEvent);\n      }, this.doubleTapInterval);\n      this._preventSingleTap = true;\n    }\n    if (!this._preventDoubleTap) {\n      // 双击点使用第一次的点\n      const firstPointer = this._firstPointer;\n      if (firstPointer) {\n        newEvent.getPoint = () => firstPointer.current;\n      }\n      newEvent.intervalTime = this.doubleTapInterval;\n      this.emit('doubleTap', newEvent);\n      this._firstPointer = null;\n      this._preventDoubleTap = true;\n    }\n    // this._swipePoints存在表示开始了swipe行为\n    if (this._swipePoints) {\n      const [prev, next] = this._swipePoints;\n      // 最后一次移动的点即为swipe终点\n      const endPos = next[next.length - 1];\n      // 最后一次移动点的时间减去手指（点）抬起的时间，此间隔时间需小于等待时间raiseDuration，否则视为停止swipe\n      if (Date.now() - endPos.timestamp <= this.raiseDuration) {\n        // 找到计入swipe的时间(swipeDuration)内的swipe起点\n        let startPos = next[0];\n        for (let i = prev.length - 1; i >= 0; i--) {\n          if (endPos.timestamp - prev[i].timestamp <= this.swipeDuration) {\n            startPos = prev[i];\n          } else {\n            break;\n          }\n        }\n        // 根据swipe起点和终点的距离差与时间差算出swipe抬起时速率\n        const velocity = getVelocity(\n          endPos.timestamp - startPos.timestamp,\n          getDistance(startPos.point, endPos.point),\n        );\n        // swipe速率需要大于swipeVelocity，否则忽略不计，不视为swipe\n        if (velocity > this.swipeVelocity) {\n          // 滑动方向与x夹角\n          const angle = getAngle(startPos.point, endPos.point);\n          // 惯性的方向\n          newEvent.direction = getDirection(startPos.point, endPos.point);\n          newEvent.angle = angle;\n          newEvent.velocity = velocity;\n          // 给出按照velocity速度滑动，当速度减到0时的计算函数：\n          // 当给出时间t，即在t时间内速度减到0，求出滑动的距离：\n          // 当给出减速度a，即在减速度a的作用下，速度减到0，求出滑动的距离，和消耗的时间：\n          // 减速度某个时间的位移：s = v0 * t - (a * t * t) / 2\n          // 减速度某个时间的速度：v = v0 - a * t\n          // s为滑动距离，v末速度为0，v0初速度为velocity\n          newEvent.swipeComputed = (factor: number, _velocity: number = velocity) => {\n            // 因子大于1可以认为传入的是时间毫秒数\n            let duration = 0;\n            let deceleration = 0;\n            let distance = 0;\n            if (factor > 1) {\n              duration = factor;\n              deceleration = _velocity / duration;\n              distance = (_velocity * duration) / 2;\n            }\n            // 因子小于1可以认为传入的是减速度（减速如果大于1一般太大了，不符合使用场景）\n            else if (factor > 0) {\n              deceleration = factor;\n              duration = _velocity / deceleration;\n              distance = (_velocity * _velocity) / (2 * deceleration);\n            }\n            const [stretchX, stretchY] = getVector(distance, angle);\n            return {\n              duration, // swipe速率减到0花费的时间\n              stretchX, // x方向swipe惯性距离（抬起后，继续移动的距离）\n              stretchY, // y方向swipe惯性距离（抬起后，继续移动的距离）\n              deceleration, // swipe速率减到0的减速度\n            };\n          };\n          /**\n           * swipe思路:\n           * 根据移动停止前swipeDuration时间内移动的距离和时间算出速度，\n           * 速度大于swipeVelocity，并且移动停止后到手指（点）抬起时间间隔小于raiseDuration即为swipe\n           * 移动停止就是最后一次触发move事件\n           * 0. start 清空_swipePoints\n           * 1. move 每swipeDuration时间内所移动的点分为一组，只保留上一次swipeDuration时间组和这一次swipeDuration时间组，存储在_swipePoints内\n           * 2. end 松开手时, 在_swipePoints内找到起终点，根据起终点距离和时间差算出速度，然后算出其他值\n           */\n          this.emit('swipe', newEvent);\n          this._swipePoints = null;\n        }\n      }\n    }\n  }\n  this.emit('pointerEnd', newEvent);\n  /* // 只剩下一根在上面了，以下事件交给用户自行放在pointerEnd事件里自行判断\n  if (this._pointer0 && !this._pointer1) {\n    // 双指抬起，只剩下一指，此时就认为该点是移动的起点（否则会把双指移动的起点作为起点，移动时会出现跳跃）\n    this._pointer0.start = this._pointer0.previous = this._pointer0.current;\n    // 同时可以触发一次start事件\n    newEvent.pointers = [this._pointer0];\n    newEvent.pointer = this._pointer0;\n    this.emit('pointerStart', newEvent);\n  } */\n}\n","/*\n * @Author: Huangjs\n * @Date: 2023-08-23 11:27:38\n * @LastEditors: Huangjs\n * @LastEditTime: 2023-09-06 15:23:25\n * @Description: ******\n */\n\nimport ended from './ended';\nimport { preventDefault, stopPropagation, stopImmediatePropagation } from './common';\nimport { isTouchable } from '../utils';\nimport type Core from '../core';\n\nexport default function canceled(this: Core, event: any) {\n  this.emit('pointerCancel', {\n    sourceEvent: event,\n    timestamp: Date.now(),\n    pointers: [],\n    leavePointers: [],\n    getPoint: () => [0, 0],\n    isTouching: () => !!isTouchable() && !!event.touches,\n    preventDefault: preventDefault.bind(event),\n    stopPropagation: stopPropagation.bind(event),\n    stopImmediatePropagation: stopImmediatePropagation.bind(event),\n  });\n  ended.apply(this, [event]);\n}\n","/*\n * @Author: Huangjs\n * @Date: 2023-08-23 11:27:38\n * @LastEditors: Huangjs\n * @LastEditTime: 2023-10-23 14:37:27\n * @Description: ******\n */\n\nimport started from './started';\nimport moved from './moved';\nimport ended from './ended';\nimport { preventDefault, stopPropagation, stopImmediatePropagation } from './common';\nimport { getDistance, getDirection } from '../utils';\nimport type Core from '../core';\nimport { type IGestureEvent } from '../core';\n\nexport default function downed(this: Core, event: any) {\n  const that = this;\n  if (that._noMouseTimer) {\n    return;\n  }\n  if (typeof window !== 'undefined') {\n    // Chrome 73之后，所有绑定在根节点（window,document,body）的scroll,wheel,mobile touch事件都会默认passive为true\n    // 这就会导致事件内调用e.preventDefault()无效，还会报错：Unable to preventDefault inside passive event listener invocation.\n    // 这里设置为false，capture为false表示冒泡阶段触发，e.stopPropagation()可用\n    window.addEventListener('mousemove', mousemoved, {\n      capture: false,\n      passive: false,\n    });\n    window.addEventListener('mouseup', mouseupped, {\n      capture: false,\n      passive: false,\n    });\n    window.addEventListener('blur', blured, {\n      capture: true,\n      passive: false,\n    });\n    // capture为true使其为捕获阶段就执行\n    window.addEventListener('dragstart', dragstarted, {\n      capture: true,\n      passive: false,\n    });\n    if ('onselectstart' in window.document.documentElement) {\n      // capture为true使其为捕获阶段就执行\n      window.addEventListener('selectstart', dragstarted, {\n        capture: true,\n        passive: false,\n      });\n    }\n  }\n  function unbind() {\n    if (typeof window !== 'undefined') {\n      window.removeEventListener('mousemove', mousemoved);\n      window.removeEventListener('mouseup', mouseupped);\n      window.removeEventListener('blur', blured);\n      window.removeEventListener('dragstart', dragstarted);\n      if ('onselectstart' in window.document.documentElement) {\n        window.removeEventListener('selectstart', dragstarted);\n      }\n    }\n  }\n  function dragstarted(e: Event) {\n    e.preventDefault();\n  }\n  function blured(e: Event) {\n    dragstarted(e);\n    unbind();\n  }\n  function mousemoved(e: MouseEvent) {\n    if (event.button === 0) {\n      moved.apply(that, [e]);\n    } else {\n      const newEvent: IGestureEvent = {\n        sourceEvent: e,\n        timestamp: Date.now(),\n        pointers: [],\n        leavePointers: [],\n        getPoint: () => [0, 0],\n        isTouching: () => false,\n        preventDefault: preventDefault.bind(e),\n        stopPropagation: stopPropagation.bind(e),\n        stopImmediatePropagation: stopImmediatePropagation.bind(e),\n      };\n      const point = [e.pageX, e.pageY];\n      if (that._pointer0 && getDistance(that._pointer0.start, point) > that.touchMoveDistance) {\n        that._pointer0.previous = that._pointer0.current;\n        that._pointer0.current = point;\n        newEvent.pointers = [that._pointer0];\n        const { start, previous, current } = that._pointer0;\n        newEvent.getPoint = (whichOne) =>\n          whichOne === 'start' ? start : whichOne === 'previous' ? previous : current;\n        newEvent.direction = getDirection(previous, current);\n        newEvent.moveDirection = getDirection(start, current);\n        newEvent.deltaX = current[0] - previous[0];\n        newEvent.moveX = current[0] - start[0];\n        newEvent.deltaY = current[1] - previous[1];\n        newEvent.moveY = current[1] - start[1];\n        // 根据移动距离计算：1度 = 4px; 正值顺时针，负值逆时针\n        newEvent.angle = newEvent.deltaX / 4;\n        newEvent.moveAngle = newEvent.moveX / 4;\n        that.emit('rotate', newEvent);\n      }\n    }\n  }\n  function mouseupped(e: MouseEvent) {\n    unbind();\n    if (event.button === 0) {\n      ended.apply(that, [e]);\n    } else {\n      const newEvent: IGestureEvent = {\n        sourceEvent: e,\n        timestamp: Date.now(),\n        pointers: [],\n        leavePointers: [],\n        getPoint: () => [0, 0],\n        isTouching: () => false,\n        preventDefault: preventDefault.bind(e),\n        stopPropagation: stopPropagation.bind(e),\n        stopImmediatePropagation: stopImmediatePropagation.bind(e),\n      };\n      const point = [e.pageX, e.pageY];\n      if (that._pointer0) {\n        const pointer0 = that._pointer0;\n        that._pointer0 = null;\n        pointer0.previous = pointer0.current;\n        pointer0.current = point;\n        newEvent.leavePointers = [pointer0];\n        const { start, previous, current } = pointer0;\n        newEvent.getPoint = (whichOne) =>\n          whichOne === 'start' ? start : whichOne === 'previous' ? previous : current;\n      }\n      newEvent.angle = 0 / 0;\n      that.emit('rotate', newEvent);\n    }\n  }\n  if (event.button === 0) {\n    started.apply(that, [event]);\n  } else {\n    // 如果存在wheel没执行，需要执行掉\n    if (that._wheelTimerEnd) {\n      clearTimeout(that._wheelTimerEnd.timer);\n      that._wheelTimerEnd.wheelEnd();\n      that._wheelTimerEnd = null;\n    }\n    const point = [event.pageX, event.pageY];\n    that._pointer0 = {\n      start: point,\n      previous: point,\n      current: point,\n      identifier: -1,\n      changed: true,\n    };\n  }\n}\n","/*\n * @Author: Huangjs\n * @Date: 2023-08-23 11:27:38\n * @LastEditors: Huangjs\n * @LastEditTime: 2023-10-11 09:32:15\n * @Description: ******\n */\n\nimport { preventDefault, stopPropagation, stopImmediatePropagation } from './common';\nimport type Core from '../core';\nimport { type IGestureEvent } from '../core';\n\nexport default function wheeled(this: Core, event: any) {\n  const newEvent: IGestureEvent = {\n    sourceEvent: event,\n    timestamp: Date.now(),\n    pointers: [],\n    leavePointers: [],\n    getPoint: () => [0, 0],\n    isTouching: () => false,\n    preventDefault: preventDefault.bind(event),\n    stopPropagation: stopPropagation.bind(event),\n    stopImmediatePropagation: stopImmediatePropagation.bind(event),\n  };\n  const point = [event.pageX, event.pageY];\n  if (this._wheelTimerEnd) {\n    if (this._pointer0) {\n      this._pointer0.previous = this._pointer0.current;\n      this._pointer0.current = point;\n    }\n    clearTimeout(this._wheelTimerEnd.timer);\n    // wheelRoll\n  } else {\n    this._pointer0 = {\n      start: point,\n      previous: point,\n      current: point,\n      identifier: -1,\n      changed: true,\n    };\n    // wheelstart\n  }\n  const wheelEnd = () => {\n    this._pointer0 = null;\n    this._wheelTimerEnd = null;\n    newEvent.timestamp = Date.now();\n    // 表示滚轮结束，不参与计算\n    newEvent.scale = 0 / 0;\n    this.emit('scale', newEvent);\n    // wheelEnd\n  };\n  this._wheelTimerEnd = {\n    wheelEnd,\n    timer: +setTimeout(wheelEnd, this.wheelDelay),\n    scale: this._wheelTimerEnd ? this._wheelTimerEnd.scale : 1,\n  };\n  if (this._pointer0) {\n    newEvent.pointers = [this._pointer0];\n    const { start, previous, current } = this._pointer0;\n    newEvent.getPoint = (whichOne) =>\n      whichOne === 'start' ? start : whichOne === 'previous' ? previous : current;\n    const scale = Math.pow(\n      2,\n      -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 0.002),\n    );\n    this._wheelTimerEnd.scale *= scale;\n    newEvent.moveScale = this._wheelTimerEnd.scale;\n    newEvent.scale = scale;\n    this.emit('scale', newEvent);\n  }\n}\n","/*\n * @Author: Huangjs\n * @Date: 2023-08-22 16:15:47\n * @LastEditors: Huangjs\n * @LastEditTime: 2023-10-20 13:15:37\n * @Description: ******\n */\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { useEvents } from './useEvents';\nimport { useIsomorphicLayoutEffect } from './useIsomorphicLayoutEffect';\nimport Core, { type IGestureOptions, type IGestureEvent } from '../core';\nimport { started, moved, ended, canceled, downed, wheeled } from '../events';\nimport { isTouchable } from '../utils';\n\nexport type IGestureRef = {\n  findDOMElement: () => Element | null | undefined;\n  getInstance: () => Core | null | undefined;\n};\n\nexport type IHandler = ((e: IGestureEvent) => void) | null;\n\nexport type IGestureHandler = {\n  onPan?: IHandler;\n  onTap?: IHandler;\n  onSwipe?: IHandler;\n  onSingleTap?: IHandler;\n  onLongTap?: IHandler;\n  onDoubleTap?: IHandler;\n  onMultiPan?: IHandler;\n  onScale?: IHandler;\n  onRotate?: IHandler;\n  onPointerStart?: IHandler;\n  onPointerMove?: IHandler;\n  onPointerEnd?: IHandler;\n  onPointerCancel?: IHandler;\n  onGestureStart?: IHandler;\n  onGestureMove?: IHandler;\n  onGestureEnd?: IHandler;\n};\n\nexport type IGestureProps = {\n  preventAllTap?: boolean;\n  options?: IGestureOptions;\n  children?: React.ReactNode;\n} & IGestureHandler;\n\nconst Gesture = React.forwardRef<IGestureRef, IGestureProps>(\n  ({ children, options, preventAllTap, ...events }, ref) => {\n    const elementRef = React.useRef<Element | null>(null);\n    const coreRef = React.useRef<Core | null>(null);\n\n    useIsomorphicLayoutEffect(() => {\n      coreRef.current = new Core();\n    }, []);\n\n    useIsomorphicLayoutEffect(() => {\n      if (coreRef.current) {\n        coreRef.current.resetOptions(options);\n      }\n    }, [options]);\n\n    useIsomorphicLayoutEffect(() => {\n      if (preventAllTap && coreRef.current) {\n        coreRef.current.preventAllTap();\n      }\n    }, [preventAllTap]);\n\n    useEvents(\n      events,\n      React.useCallback(() => coreRef.current, []),\n    );\n\n    React.useImperativeHandle(\n      ref,\n      (): IGestureRef => ({\n        findDOMElement: () => elementRef.current,\n        getInstance: () => coreRef.current,\n      }),\n      [],\n    );\n\n    // 这里ref函数使用useCallback，为了使每次渲染ref函数为同一个函数\n    // 如果函数直接写在下面的ref里，如下所示，则箭头函数在每次渲染都相当于重新创建\n    // 此时react里会比较发现ref函数变化，就会先执行变化前的函数，传入null，再执行变化后的函数，传入实际值\n    // React.cloneElement(children, {\n    //   ref: (a)=>{\n    //     ...\n    //   },\n    // })\n    const refFun = React.useCallback((_ref: React.ReactInstance) => {\n      let element: any = _ref;\n      // ref是Element的时候不需要查找，只有是React.Component的时候才可以查找\n      if (!(_ref instanceof Element) && _ref instanceof React.Component) {\n        element = ReactDOM.findDOMNode(_ref);\n      }\n      if (!(element instanceof Element)) {\n        element = null;\n      }\n      elementRef.current = element;\n    }, []);\n\n    const bind = (emitter: (args: any) => void, args: any) => {\n      const core = coreRef.current;\n      if (core) {\n        emitter.apply(core, args);\n      }\n    };\n    const listener = React.useMemo(\n      () => ({\n        ...(isTouchable()\n          ? {\n              onTouchStart: (...args: any) => bind(started, args),\n              onTouchMove: (...args: any) => bind(moved, args),\n              onTouchEnd: (...args: any) => bind(ended, args),\n              onTouchCancel: (...args: any) => bind(canceled, args),\n            }\n          : {}),\n        onMouseDown: (...args: any) => bind(downed, args),\n        onWheel: (...args: any) => bind(wheeled, args),\n      }),\n      [],\n    );\n\n    if (!children) {\n      console.warn('Warning: Gesture children must exist.');\n      return null;\n    }\n    return React.Children.only(\n      React.cloneElement(children as any, {\n        ref: refFun,\n        ...listener,\n      }),\n    );\n  },\n);\n\nexport * from '../core';\n\nexport default Gesture;\n"],"names":["useIsomorphicLayoutEffect","window","document","createElement","React","useLayoutEffect","useEffect","useEvent","getCore","type","onEvent","core","handler","e","apply","on","off","EventEmitter","constructor","this","events","one","single","onceHandler","args","pool","push","unregistered","i","len","length","splice","emit","event","isCurrentTarget","target","currentTarget","_target","parentNode","fixOption","value","defaultValue","minVal","isTouchable","navigator","maxTouchPoints","getEventPoints","started","touches","points","Array","prototype","filter","call","t","map","pageX","pageY","identifier","isFirst","changedTouches","slice","getDistance","x0","y0","x1","y1","Math","sqrt","pow","getAngle","atan2","PI","getCenter","ok0","ok1","getDirection","x","y","abs","options","super","wheelDelay","longTapInterval","doubleTapInterval","doubleTapDistance","touchMoveDistance","swipeVelocity","swipeDuration","raiseDuration","_rotateAngle","_noMouseTimer","_singleTapTimer","_longTapTimer","_wheelTimerEnd","_preventTap","_swipePoints","_preventSingleTap","_preventDoubleTap","_firstPointer","_pointer0","_pointer1","resetOptions","preventAllTap","fp","clearTimeout","preventDefault","nativeEvent","returnValue","stopPropagation","cancelBubble","stopImmediatePropagation","newEvent","sourceEvent","timestamp","Date","now","pointers","leavePointers","getPoint","isTouching","bind","timer","wheelEnd","changed","p","pointer","start","previous","current","pointer0","pointer1","setTimeout","waitTime","firstPointer","singleTapTimer","moved","start0","previous0","current0","start1","previous1","current1","eCenter","mCenter","sCenter","whichOne","direction","moveDirection","deltaX","moveX","deltaY","moveY","eDistance","mDistance","sDistance","scale","moveScale","angle","moveAngle","_timestamp","point","ended","delayTime","intervalTime","prev","next","endPos","startPos","velocity","deltaTime","distance","swipeComputed","factor","_velocity","duration","deceleration","stretchX","stretchY","rad","cos","sin","getVector","canceled","downed","that","addEventListener","mousemoved","capture","passive","mouseupped","blured","dragstarted","documentElement","button","unbind","removeEventListener","wheeled","deltaMode","Gesture","forwardRef","_ref2","ref","children","_objectWithoutPropertiesLoose","_excluded","elementRef","useRef","coreRef","Core","onPan","onTap","onSwipe","onSingleTap","onLongTap","onDoubleTap","onMultiPan","onScale","onRotate","onPointerStart","onPointerMove","onPointerEnd","onPointerCancel","onGestureStart","onGestureMove","onGestureEnd","useEvents","useCallback","useImperativeHandle","findDOMElement","getInstance","refFun","_ref","element","Element","Component","ReactDOM","findDOMNode","emitter","listener","useMemo","_extends","onTouchStart","onTouchMove","onTouchEnd","onTouchCancel","onMouseDown","onWheel","Children","only","cloneElement","console","warn"],"mappings":"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"}